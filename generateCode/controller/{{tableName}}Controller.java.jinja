/*
* Copyright 2024 E.J.I.E., S.A.
*
* Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
* Solo podrá usarse esta obra si se respeta la Licencia.
* Puede obtenerse una copia de la Licencia en
*
* http://ec.europa.eu/idabc/eupl.html
*
* Salvo cuando lo exija la legislación aplicable o se acuerde por escrito,
* el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
* SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
* Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
* que establece la Licencia.
*/
package {{packageName}}.control;

{# imports necesarios #}
import com.ejie.x38.control.bind.annotation.RequestJsonBody;
import com.ejie.x38.dto.TableRequestDto;
import com.ejie.x38.dto.TableResponseDto;
import com.ejie.x38.dto.TableRowDto;
import com.ejie.x38.util.DateTimeManager;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.propertyeditors.CustomDateEditor;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.ServletRequestDataBinder;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.InitBinder;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.ResponseStatus;
import java.util.Date;
import java.util.List;
import java.util.ArrayList;
import org.springframework.web.multipart.support.ByteArrayMultipartFileEditor; {# fin imports necesarios#}
import {{packageName}}.service.{{tableName}}Service;
{% for column in columnsDates 
	if column.DATA_IMPORT != ''%}
import {{ column.DATA_IMPORT }};{% endfor %}
import {{packageName}}.model.{{tableName}};
{% if controller is not none %}
import {{packageName}}.model.{{entidadRelacion}};
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
{%endif%}

/**
 * {{tableName}}Controller generated by UDA", {{date}}.
 * @author UDA
 */

@Controller
@RequestMapping(value = "/{{tableNameOriginal|snakeToCamel}}")

public class {{tableName}}Controller  {
	private static final Logger logger = LoggerFactory.getLogger({{tableName}}Controller.class);

	@Autowired
	private {{tableName}}Service {{tableNameDecapitalize}}Service;

	@InitBinder
	protected void initBinder(HttpServletRequest request, ServletRequestDataBinder binder) throws ServletException {
		binder.registerCustomEditor(byte[].class,new ByteArrayMultipartFileEditor());
		binder.registerCustomEditor(Date.class, new CustomDateEditor(DateTimeManager.getDateTimeFormat(LocaleContextHolder.getLocale()), true));
	}
	
	/*
	 * OPERACIONES CRUD (Create, Read, Update, Delete)
	 */
	
	/**
	 * Operación CRUD Read. Devuelve el bean correspondiente al identificador indicado.
	 * {% for column in columnsDates %}{% if column.primaryKey == 'P'%} 
	 * @param {{ column.name.lower() }} {{ column.DATO_TYPE }}{% endif%}{% endfor %}
	 *
	 * @return {{tableName}} Objeto correspondiente al identificador indicado.
	 */

	@GetMapping(value = "{%for i in listPks %}/{{'{'}}{{ i.name|snakeToCamel }}{{'}'}}{% endfor %}")
	public @ResponseBody {{tableName}} get({%for i in listPks %}@PathVariable {{i.DATO_TYPE}} {{ i.name|snakeToCamel }} {% if loop.index != listPks|length %},{% endif%} {% endfor %}) {
        {{tableName}} {{tableNameDecapitalize}} = new {{tableName}}();
		{%for i in listPks %}
		{{tableNameDecapitalize}}.set{{ i.name|toCamelCase }}({{ i.name|snakeToCamel }});
		{% endfor %}
        {{tableNameDecapitalize}} = this.{{tableNameDecapitalize}}Service.find({{tableNameDecapitalize}});
        {{tableName}}Controller.logger.info("[GET - findBy_PK] : Obtener {{tableName}} por PK");
        return {{tableNameDecapitalize}};
	}

	/**
	 * Devuelve una lista de beans correspondientes a los valores de filtrados
	 * indicados en el objeto pasado como parametro.
	 *
	 * @param filter{{tableName}} {{tableName}}
	 *            Objeto que contiene los parametros de filtrado utilizados en
	 *            la busqueda.
	 * @return List<{{tableName}}> 
	 *            Lista de objetos correspondientes a la busqueda realizada.
	 */
	@GetMapping(value = "/all")
	public @ResponseBody List<{{tableName}}> getAll(@ModelAttribute {{tableName}} filter{{tableName}}) {
		{{tableName}}Controller.logger.info("[GET - find_ALL] : Obtener {{tableName}} por filtro");
	    return this.{{tableNameDecapitalize}}Service.findAll(filter{{tableName}}, null);
	}

	/**
	 * Operacion CRUD Edit. Modificacion del bean indicado.
	 *
	 * @param {{tableNameDecapitalize}} {{tableName}} 
	 *            Bean que contiene la informacion a modificar.
	 * @return {{tableName}} 
	 *            Bean resultante de la modificacion.
	 */
	@PutMapping(value = "/edit")
    public @ResponseBody {{tableName}} edit(@RequestBody {{tableName}} {{tableNameDecapitalize}}) {		
        {{tableName}} {{tableNameDecapitalize}}Aux = this.{{tableNameDecapitalize}}Service.update({{tableNameDecapitalize}});
		{{tableName}}Controller.logger.info("[PUT] : {{tableName}} actualizado correctamente");
        return {{tableNameDecapitalize}}Aux;
    }

	/**
	 * Operacion CRUD Create. Creacion de un nuevo registro a partir del bean
	 * indicado.
	 *
	 * @param {{tableNameDecapitalize}} {{tableName}} 
	 *            Bean que contiene la informacion con la que se va a crear el
	 *            nuevo registro.
	 * @return {{tableName}}
	 *            Bean resultante del proceso de creacion.
	 */
	@PostMapping(value = "/add")
	public @ResponseBody {{tableName}} add(@RequestBody {{tableName}} {{tableNameDecapitalize}}) {		
        {{tableName}} {{tableNameDecapitalize}}Aux = this.{{tableNameDecapitalize}}Service.add({{tableNameDecapitalize}});
        {{tableName}}Controller.logger.info("[POST] : {{tableName}} insertado correctamente");
    	return {{tableNameDecapitalize}}Aux;
	}

	/**
	 * Operación CRUD Delete. Borrado del registro correspondiente al identificador indicado.
	 * {% for column in columnsDates %}{% if column.primaryKey == 'P'%} 
	 * @param {{ column.name.lower() }} {{ column.DATO_TYPE }}{% endif%}{% endfor %}
	 *
	 * @return {{tableName}} Objeto correspondiente al identificador indicado.
	 */

	@DeleteMapping(value = "{%for i in listPks %}/{{'{'}}{{ i.name|snakeToCamel }}{{'}'}}{% endfor %}")
	public @ResponseBody {{tableName}} remove({%for i in listPks %}@PathVariable {{i.DATO_TYPE}} {{ i.name|snakeToCamel }} {% if loop.index != listPks|length %},{% endif%} {% endfor %}) {
        {{tableName}} {{tableNameDecapitalize}} = new {{tableName}}();
		{%for i in listPks %}
		{{tableNameDecapitalize}}.set{{ i.name|toCamelCase }}({{ i.name|snakeToCamel }});
		{% endfor %}
        this.{{tableNameDecapitalize}}Service.remove({{tableNameDecapitalize}});
        {{tableName}}Controller.logger.info("[DELETE] : Obtener {{tableName}} borrado correctamente");
        return {{tableNameDecapitalize}};
	}    
	
	/*
	 * MÉTODOS COMPONENTE RUP_TABLE
	 */

	 /**
	 * Metodo de presentacion del RUP_TABLE.
	 * 
	 * @param model Model
	 * @return String
	 */
	@GetMapping(value = "/maint")
	public String getFormEdit(Model model) {
		{{tableName}}Controller.logger.info("[GET - View] : {{tableNameOriginal|snakeToCamel}}");
		model.addAttribute("{{tableNameOriginal|snakeToCamel}}", new {{tableName}}());
		{% if typeTemplate == "tiles" %}
		return "{{tableNameOriginal|snakeToCamel}}";
		{% else %}
		model.addAttribute("content", "{{tableNameOriginal|snakeToCamel}}/{{tableNameOriginal|snakeToCamel}}");
		model.addAttribute("includes", "{{tableNameOriginal|snakeToCamel}}/{{tableNameOriginal|snakeToCamel}}-includes");
		return "template";
		{% endif %}
	}
	 
	 /**
	 * Operacion de filtrado del componente RUP_TABLE.
	 * 
	 * @param filter{{tableName}} {{tableName}}
	 *            Bean que contiene los parametros de filtrado a emplear.
	 * @param tableRequestDto
	 *            Dto que contiene los parametros de configuracion propios del
	 *            RUP_TABLE a aplicar en el filtrado.
	 * @return TableResponseDto<{{tableName}}>
	 *            Dto que contiene el resultado del filtrado realizado por el 
	 *            componente RUP_TABLE.
	 */
	@PostMapping(value = "/filter")
	public @ResponseBody TableResponseDto<{{tableName}}> filter(
			@RequestJsonBody(param="filter") {{tableName}} filter{{tableName}},
			@RequestJsonBody TableRequestDto tableRequestDto) {
		{{tableName}}Controller.logger.info("[POST - filter] : Obtener {{tableName}}s");
		return this.{{tableNameDecapitalize}}Service.filter(filter{{tableName}}, tableRequestDto, false);
	}
	 
	/**
	 * Operacion de busqueda del componente RUP_TABLE.
	 * 
	 * @param filter{{tableName}} {{tableName}}
	 *            Bean que contiene los parametros de filtrado a emplear.
	 * @param search{{tableName}} {{tableName}}
	 *            Bean que contiene los parametros de busqueda a emplear.
	 * @param tableRequestDto
	 *            Dto que contiene los parametros de configuracion propios del
	 *            RUP_TABLE a aplicar en la búsqueda.
	 * @return TableRowDto<{{tableName}}> 
	 *            Dto que contiene el resultado de la busqueda realizada por el
	 *            componente RUP_TABLE. 
	 */
	@PostMapping(value = "/search")
	public @ResponseBody List<TableRowDto<{{tableName}}>> search(
			@RequestJsonBody(param="filter") {{tableName}} filter{{tableName}},
			@RequestJsonBody(param="search") {{tableName}} search{{tableName}},
			@RequestJsonBody TableRequestDto tableRequestDto) {
		{{tableName}}Controller.logger.info("[POST - search] : Buscar {{tableName}}s");
		return this.{{tableNameDecapitalize}}Service.search(filter{{tableName}}, search{{tableName}}, tableRequestDto, false);
	}
	
	/**
	 * Borrado multiple de registros
	 * 
	 * @param filter{{tableName}} {{tableName}}
	 *            Bean que contiene los parametros de filtrado a emplear.
	 * @param tableRequestDto
	 *            Dto que contiene los parametros de configuracion propios del
	 *            RUP_TABLE a aplicar en la busqueda.
	 * @return List<String>
	 *            Lista de los identificadores de los registros eliminados.
	 * 
	 */
	@PostMapping(value = "/deleteAll")
	@ResponseStatus(value = HttpStatus.OK)
	public @ResponseBody List<String> removeMultiple(
			@RequestJsonBody(param="filter") {{tableName}} filter{{tableName}},
			@RequestJsonBody TableRequestDto tableRequestDto) {
		{{tableName}}Controller.logger.info("[POST - removeMultiple] : Eliminar multiples {{tableName}}s");
		this.{{tableNameDecapitalize}}Service.removeMultiple(tableRequestDto);
		{{tableName}}Controller.logger.info("All entities correctly deleted!");
		
		return tableRequestDto.getMultiselection().getSelectedIds();
	}
	
	/**
 	 * EXPORTERS
 	 */
	
	/**
	 * Devuelve los datos exportados de la tabla y los copia al Portapapeles.
	 *
	 * @param filter{{tableName}} {{tableName}}
	 * @param tableRequestDto TableRequestDto
	 */	 
	@PostMapping(value = "/clipboardReport")
	protected @ResponseBody List<{{tableName}}> getClipboardReport(
			@RequestJsonBody(param="filter") {{tableName}}  filter{{tableName}} ,
			@RequestJsonBody TableRequestDto  tableRequestDto) {
		{{tableName}}Controller.logger.info("[POST - clipboardReport] : : Copiar en Portapapeles");
		return this.{{tableNameDecapitalize}}Service.getDataForReports(filter{{tableName}}, tableRequestDto);
	}
	
	/**
	 * Devuelve un fichero excel que contiene los datos exportados de la tabla.
	 *
	 * @param filter          {{tableName}}
	 * @param columns         String[]
	 * @param fileName        String
	 * @param sheetTitle      String
	 * @param tableRequestDto TableRequestDto
	 * @param request         HttpServletRequest
	 * @param response        HttpServletResponse
	 */
	@PostMapping(value = { "/xlsReport","/xlsxReport" }, produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	protected @ResponseBody void generateExcelReport(@RequestJsonBody(param = "filter", required = false) {{tableName}} filter,
			@RequestJsonBody(param = "columns", required = false) String[] columns,
			@RequestJsonBody(param = "columnsName", required = false) String[] columnsName,
			@RequestJsonBody(param = "fileName", required = false) String fileName,
			@RequestJsonBody(param = "sheetTitle", required = false) String sheetTitle,
			@RequestJsonBody(param = "reportsParams", required = false) ArrayList<?> reportsParams,
			@RequestJsonBody TableRequestDto tableRequestDto, HttpServletRequest request, HttpServletResponse response)
			throws ServletException {
		{{tableName}}Controller.logger.info("[POST - generateExcelReport] : Devuelve un fichero excel");

		this.{{tableNameDecapitalize}}Service.generateReport(filter, columns,columnsName, fileName, sheetTitle,reportsParams, tableRequestDto, request, response);
	}
	
		/**
	 * Devuelve un fichero pdf que contiene los datos exportados de la tabla.
	 *
	 * @param filter          {{tableName}}
	 * @param columns         String[]
	 * @param fileName        String
	 * @param sheetTitle      String
	 * @param tableRequestDto TableRequestDto
	 * @param request         HttpServletRequest
	 * @param response        HttpServletResponse
	 */
	@PostMapping(value = "pdfReport", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	protected @ResponseBody void generatePDFReport(@RequestJsonBody(param = "filter", required = false) {{tableName}} filter,
			@RequestJsonBody(param = "columns", required = false) String[] columns,
			@RequestJsonBody(param = "columnsName", required = false) String[] columnsName,
			@RequestJsonBody(param = "fileName", required = false) String fileName,
			@RequestJsonBody(param = "sheetTitle", required = false) String sheetTitle,
			@RequestJsonBody(param = "reportsParams", required = false) ArrayList<?> reportsParams,
			@RequestJsonBody TableRequestDto tableRequestDto, HttpServletRequest request,
			HttpServletResponse response) {
		{{tableName}}Controller.logger.info("[POST - generatePDFReport] : Devuelve un fichero pdf");

		this.{{tableNameDecapitalize}}Service.generateReport(filter, columns,columnsName, fileName, sheetTitle,reportsParams, tableRequestDto, request, response);
	}
	
		/**
	 * Devuelve un fichero ods que contiene los datos exportados de la tabla.
	 *
	 * @param filter          {{tableName}}
	 * @param columns         String[]
	 * @param fileName        String
	 * @param sheetTitle      String
	 * @param tableRequestDto TableRequestDto
	 * @param request         HttpServletRequest
	 * @param response        HttpServletResponse
	 */
	@PostMapping(value = "odsReport", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	protected @ResponseBody void generateODSReport(@RequestJsonBody(param = "filter", required = false) {{tableName}} filter,
			@RequestJsonBody(param = "columns", required = false) String[] columns,
			@RequestJsonBody(param = "columnsName", required = false) String[] columnsName,
			@RequestJsonBody(param = "fileName", required = false) String fileName,
			@RequestJsonBody(param = "sheetTitle", required = false) String sheetTitle,
			@RequestJsonBody(param = "reportsParams", required = false) ArrayList<?> reportsParams,
			@RequestJsonBody TableRequestDto tableRequestDto, HttpServletRequest request,
			HttpServletResponse response) {
		{{tableName}}Controller.logger.info("[POST - generateODSReport] : Devuelve un fichero ods");

		this.{{tableNameDecapitalize}}Service.generateReport(filter, columns,columnsName, fileName, sheetTitle,reportsParams, tableRequestDto, request, response);
	}

	/**
	 * Devuelve un fichero csv que contiene los datos exportados de la tabla.
	 *
	 * @param filter          {{tableName}}
	 * @param columns         String[]
	 * @param fileName        String
	 * @param sheetTitle      String
	 * @param tableRequestDto TableRequestDto
	 * @param request         HttpServletRequest
	 * @param response        HttpServletResponse
	 */
	@PostMapping(value = "csvReport", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
	protected @ResponseBody void generateCSVReport(@RequestJsonBody(param = "filter", required = false) {{tableName}} filter,
			@RequestJsonBody(param = "columns", required = false) String[] columns,
			@RequestJsonBody(param = "columnsName", required = false) String[] columnsName,
			@RequestJsonBody(param = "fileName", required = false) String fileName,
			@RequestJsonBody(param = "sheetTitle", required = false) String sheetTitle,
			@RequestJsonBody(param = "reportsParams", required = false) ArrayList<?> reportsParams,
			@RequestJsonBody TableRequestDto tableRequestDto, HttpServletRequest request,
			HttpServletResponse response) {
		{{tableName}}Controller.logger.info("[POST - generateCSVReport] : Devuelve un fichero csv");

		this.{{tableNameDecapitalize}}Service.generateReport(filter, columns,columnsName, fileName, sheetTitle,reportsParams, tableRequestDto, request, response);
	}
	
	
	{% if controller is not none %}

		/**
	* Method 'unBind' 
	*
	* @param {{colControllerPk[0][0].name|snakeToCamel}} {{colControllerPk[0][0].DATO_TYPE|snakeToCamel}}
	* @param {{colControllerPkRel[0][0].tableName|snakeToCamel}}{{colControllerPkRel[0][0].name|snakeToCamel}} {{colControllerPkRel[0][0].DATO_TYPE|snakeToCamel}} 
	*/
	@RequestMapping(value = "/unbind", method = RequestMethod.POST)
	public void unBind(
	@RequestParam(value = "{{colControllerPk[0][0].name|snakeToCamel}}", required = false) {{colControllerPk[0][0].DATO_TYPE}} {{colControllerPk[0][0].name|snakeToCamel}},
	@RequestParam(value = "{{colControllerPkRel[0][0].tableName|snakeToCamel}}{{colControllerPkRel[0][0].name|toCamelCase}}", required = false) {{colControllerPkRel[0][0].DATO_TYPE}} {{colControllerPkRel[0][0].tableName|snakeToCamel}}{{colControllerPkRel[0][0].name|toCamelCase}}
	) {
		{{tableName}} {{tableName|snakeToCamel}} = new {{tableName}}();
		{{entidadRelacion}} {{entidadRelacion|snakeToCamel}} = new {{entidadRelacion}}();
		
		if ({{colControllerPk[0][0].name|snakeToCamel}} != null) {
			{{tableName|snakeToCamel}}.set{{colControllerPk[0][0].name|toCamelCase}}({{colControllerPk[0][0].name|snakeToCamel}});
		}
		
		if ({{colControllerPkRel[0][0].tableName|snakeToCamel}}{{colControllerPkRel[0][0].name|toCamelCase}} != null) {
			{{entidadRelacion|snakeToCamel}}.set{{colControllerPkRel[0][0].name|toCamelCase}}({{colControllerPkRel[0][0].tableName|snakeToCamel}}{{colControllerPkRel[0][0].name|toCamelCase}});
		}
		
		{{tableName|snakeToCamel}}.get{{entidadRelacion}}s().add({{entidadRelacion|snakeToCamel}});
		this.{{tableName|snakeToCamel}}Service.remove({{tableName|snakeToCamel}});    
	}

	
		/**
	* Method 'bind' 
	*
	* @param {{colControllerPk[0][0].name|snakeToCamel}} {{colControllerPk[0][0].DATO_TYPE|snakeToCamel}}
	* @param {{colControllerPkRel[0][0].tableName|snakeToCamel}}{{colControllerPkRel[0][0].name|snakeToCamel}} {{colControllerPkRel[0][0].DATO_TYPE|snakeToCamel}} 
	*/
	@RequestMapping(value = "/bind", method = RequestMethod.POST)
	public void bind(
	@RequestParam(value = "{{colControllerPk[0][0].name|snakeToCamel}}", required = false) {{colControllerPk[0][0].DATO_TYPE}} {{colControllerPk[0][0].name|snakeToCamel}},
	@RequestParam(value = "{{colControllerPkRel[0][0].tableName|snakeToCamel}}{{colControllerPkRel[0][0].name|toCamelCase}}", required = false) {{colControllerPkRel[0][0].DATO_TYPE}} {{colControllerPkRel[0][0].tableName|snakeToCamel}}{{colControllerPkRel[0][0].name|toCamelCase}}
	) {
		{{tableName}} {{tableName|snakeToCamel}} = new {{tableName}}();
		{{entidadRelacion}} {{entidadRelacion|snakeToCamel}} = new {{entidadRelacion}}();
		
		if ({{colControllerPk[0][0].name|snakeToCamel}} != null) {
			{{tableName|snakeToCamel}}.set{{colControllerPk[0][0].name|toCamelCase}}({{colControllerPk[0][0].name|snakeToCamel}});
		}
		
		if ({{colControllerPkRel[0][0].tableName|snakeToCamel}}{{colControllerPkRel[0][0].name|toCamelCase}} != null) {
			{{entidadRelacion|snakeToCamel}}.set{{colControllerPkRel[0][0].name|toCamelCase}}({{colControllerPkRel[0][0].tableName|snakeToCamel}}{{colControllerPkRel[0][0].name|toCamelCase}});
		}
		
		{{tableName|snakeToCamel}}.get{{entidadRelacion}}s().add({{entidadRelacion|snakeToCamel}});
		this.{{tableName|snakeToCamel}}Service.remove({{tableName|snakeToCamel}});    
	}
	{% endif %}
}