/* 
 -- Copyright 2024 E.J.I.E., S.A.
 --
 -- Licencia con arreglo a la EUPL, Versión 1.1 exclusivamente (la «Licencia»);
 -- Solo podrá usarse esta obra si se respeta la Licencia.
 -- Puede obtenerse una copia de la Licencia en
 --
 --      http://ec.europa.eu/idabc/eupl.html
 --
 -- Salvo cuando lo exija la legislación aplicable o se acuerde por escrito, 
 -- el programa distribuido con arreglo a la Licencia se distribuye «TAL CUAL»,
 -- SIN GARANTÍAS NI CONDICIONES DE NINGÚN TIPO, ni expresas ni implícitas.
 -- Véase la Licencia en el idioma concreto que rige los permisos y limitaciones
 -- que establece la Licencia.
*/
package {{packageNameRemoting}};
import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.ejb.Remote;
import javax.ejb.Stateless;
import javax.ejb.TransactionAttribute;
import javax.ejb.TransactionAttributeType;
import javax.ejb.TransactionManagement;
import javax.ejb.TransactionManagementType;
import javax.interceptor.Interceptors;
import {{namePackageEjb}};
import org.slf4j.LoggerFactory;
import org.slf4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.ejb.interceptor.SpringBeanAutowiringInterceptor;
import com.ejie.x38.remote.RemoteEJBFactory;
import com.ejie.x38.remote.TransactionMetadata;
import com.ejie.x38.remote.TransactionMetadataStubInterceptor;
import com.ejie.x38.util.StackTraceManager;
{%for parametro in listaImports:%}
import {{parametro|replaceDto}};
{% endfor %}

/**
 * {{serviceName}} + "Stub generated by UDA".
 * @author UDA
 */

@Stateless(mappedName = "{{jndiName}}")
@TransactionManagement(TransactionManagementType.CONTAINER)
@TransactionAttribute(TransactionAttributeType.NOT_SUPPORTED)
@Interceptors({SpringBeanAutowiringInterceptor.class, TransactionMetadataStubInterceptor.class})
@Remote({{serviceName}}StubRemote.class)
@SuppressWarnings("rawtypes")
public class {{serviceName}}Stub implements {{serviceName}}StubRemote   {
	private static final Logger logger = LoggerFactory.getLogger({{serviceName}}Stub.class);

	private {{serviceName}}SkeletonRemote {{serviceName|fistLetterMin}}SkeletonRemote;

	@Autowired
	private RemoteEJBFactory remoteEJBFactory;

{%for metodo in metodos:%}
{% set method_name, ret_type, param_types = extract_java_types(metodo) %}
	/**
	 * Method {{method_name}}.
	{% for param in param_types %}
	 * @param {{ param }} {{ param }} 
	{% endfor %}
	 * @return {{ ret_type }}
	 */

	@Override
	@TransactionAttribute (TransactionAttributeType.REQUIRED)
	public {{ ret_type }} {{method_name}} ({%for param in param_types %}{{param}} arg{{loop.index }} {% if loop.index != param_types|length %},{% endif%} {% endfor %})
		return this.{{serviceName|fistLetterMin}}SkeletonRemote.{{method_name}}({%for param in param_types %}arg{{loop.index }} {% if loop.index != param_types|length %},{% endif%} {% endfor %}, new TransactionMetadata(this.getClass().getName(), Thread.currentThread().getStackTrace()[1].getMethodName()));
	}
{% endfor %}
	@SuppressWarnings("unused")
	@PostConstruct
	private void init(){
		try{
			{{serviceName|fistLetterMin}}SkeletonRemote = ({{serviceName}}SkeletonRemote) remoteEJBFactory.lookup("{{nameServer}}", {{serviceName}}SkeletonRemote.class);
			logger.info("Obtained remote Skeleton is: "+{{serviceName|fistLetterMin}}SkeletonRemote.toString());
		}catch(Exception e){
			logger.error(StackTraceManager.getStackTrace(e));
		}
	}
	
	@SuppressWarnings("unused")
	@PreDestroy
	private void destroy(){
		logger.info("Deleting cached instance of "+{{serviceName}}SkeletonRemote.class+" before destroying this EJB");
		remoteEJBFactory.clearInstance({{serviceName}}SkeletonRemote.class);
	}

	public RemoteEJBFactory getRemoteEJBFactory() {
		return remoteEJBFactory;
	}

	public void setRemoteEJBFactory(RemoteEJBFactory remoteEJBFactory) {
		this.remoteEJBFactory = remoteEJBFactory;
	}
}